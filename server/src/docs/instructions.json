{
	"add": {
		"title": "add",
		"summary": "Arithmetic Add",
		"operation": "[destination] ← [source] + [destination]",
		"syntax": [
			"add <source>,<destination>"
		],
		"description": "Add the source operand to the destination operand and store the result in the destination location.",
		"src": {
			"dn": true,
			"an": true,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "*",
			"c": "*",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"and": {
		"title": "AND",
		"summary": "Logical AND",
		"operation": "[destination] ← [source] . [destination]",
		"syntax": [
			"and <source>,<destination>"
		],
		"description": "`AND` the source operand to the destination operand and store the result in the destination location.",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "*",
			"c": "0",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bcc": {
		"title": "Bcc",
		"summary": "Branch Conditionally: Carry Clear",
		"operation": "If C̅ THEN [PC] ← [PC] + d",
		"syntax": [
			"bcc <label>"
		],
		"description": "If the the carry bit is clear, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset. A short branch to the next instruction is impossible, since the branch code 0 indicates a long branch with a 16-bit offset. The assembly language form `BCC *+8` means branch to the point eight bytes from the current PC if the carry bit is clear.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bcs": {
		"title": "Bcs",
		"summary": "Branch Conditionally: Carry Set",
		"operation": "If C THEN [PC] ← [PC] + d",
		"syntax": [
			"bcs <label>"
		],
		"description": "If the the carry bit is set, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset. A short branch to the next instruction is impossible, since the branch code 0 indicates a long branch with a 16-bit offset. The assembly language form `BCS *+8` means branch to the point eight bytes from the current PC if the carry bit is set.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"beq": {
		"title": "Beq",
		"summary": "Branch Conditionally: Equal",
		"operation": "If Z THEN [PC] ← [PC] + d",
		"syntax": [
			"beq <label>"
		],
		"description": "If the the zero bit is set, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset. A short branch to the next instruction is impossible, since the branch code 0 indicates a long branch with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bge": {
		"title": "Bge",
		"summary": "Branch Conditionally: Greater or Equal",
		"operation": "If N.V + N̅.V THEN [PC] ← [PC] + d",
		"syntax": [
			"bge <label>"
		],
		"description": "If greater than or equal, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bgt": {
		"title": "Bgt",
		"summary": "Branch Conditionally: Greater Than",
		"operation": "If N.V.Z̅ + N̅.V̅.Z THEN [PC] ← [PC] + d",
		"syntax": [
			"bgt <label>"
		],
		"description": "If greater than, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"ble": {
		"title": "Ble",
		"summary": "Branch Conditionally: Less or Equal",
		"operation": "If Z + N.V̅ + N̅.V THEN [PC] ← [PC] + d",
		"syntax": [
			"ble <label>"
		],
		"description": "If less than or equal, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"blt": {
		"title": "Blt",
		"summary": "Branch Conditionally: Less Than",
		"operation": "If N.V̅ + N̅.V THEN [PC] ← [PC] + d",
		"syntax": [
			"blt <label>"
		],
		"description": "If less than, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bmi": {
		"title": "Bmi",
		"summary": "Branch Conditionally: Minus",
		"operation": "If N THEN [PC] ← [PC] + d",
		"syntax": [
			"bmi <label>"
		],
		"description": "If the negative bit is set, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bne": {
		"title": "Bne",
		"summary": "Branch Conditionally: Not Equal",
		"operation": "If Z̅ THEN [PC] ← [PC] + d",
		"syntax": [
			"beq <label>"
		],
		"description": "If the the zero bit is clear, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset. A short branch to the next instruction is impossible, since the branch code 0 indicates a long branch with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bvc": {
		"title": "Bvc",
		"summary": "Branch Conditionally: Overflow Clear",
		"operation": "If V̅ THEN [PC] ← [PC] + d",
		"syntax": [
			"bvc <label>"
		],
		"description": "If the overflow bit is clear, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bvs": {
		"title": "Bvs",
		"summary": "Branch Conditionally: Overflow Set",
		"operation": "If V THEN [PC] ← [PC] + d",
		"syntax": [
			"bvs <label>"
		],
		"description": "If the overflow bit is set, program execution continues at location [PC] + displacement, d. The displacement is a two's complement value. The value in the PC corresponds to the current location plus two. The range of the branch is -126 to +128 bytes with an 8-bit offset, and -32K to +32K bytes with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bra": {
		"title": "BRA",
		"summary": "Branch",
		"operation": "[PC] ← [PC] + d",
		"syntax": [
			"bra <label>",
			"bra <literal>"
		],
		"description": "Program execution continues at location [PC] + d. The displacement, d, is a two's complement value (8 bits for a short branch and 16 bits for a long branch). The value in the PC corresponds to the current location plus two. Note that a short branch to the next instruction is impossible, since the branch code 0 is used to indicate a long branch with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"bsr": {
		"title": "BSR",
		"summary": "Branch to Subroutine",
		"operation": "[SP] ← [SP] - 4; [M([SP])] ← [PC]; [PC] ← [PC] + d\n",
		"syntax": [
			"bsr <label>"
		],
		"description": "The longword address of the instruction immediately following the `BSR` instruction is pushed onto the system stack pointed at by A7. Program execution then continues at location [PC] + displacement. The displacement is an 8-bit two's complement value for a short branch, or a 16-bit two's complement value for a long branch. The value in the PC corresponds to the current location plus two. Note that a short branch to the next instruction is impossible, since the branch code 0 is used to indicate a long branch with a 16-bit offset.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"clr": {
		"title": "CLR",
		"summary": "Clear",
		"operation": "[destination] ← 0",
		"syntax": [
			"clr <destination>"
		],
		"description": "The destination is cleared - loaded with all zeros. The `CLR` instruction can't be used to clear an address register. You can use `SUBA.L A0,A0` to clear A0. Note that a side effect of `CLR`'s implementation is a *read* from the specified effective address before the clear (i.e., write) operation is executed. Under certain circumstances this might cause a problem (e.g., with write-only memory).",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"cmp": {
		"title": "CMP",
		"summary": "Compare",
		"operation": "[destination] - [source]",
		"syntax": [
			"cmp <source>,Dn"
		],
		"description": "Subtract the source operand from the destination operand and set the condition codes accordingly. The destination must be a data register. The destination is not modified by this instruction.",
		"src": {
			"dn": true,
			"an": true,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"flags": {
			"z": "*",
			"c": "0",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"divs": {
		"title": "DIVS",
		"summary": "Signed Divide Long",
		"operation": "[destination] ← [destination]/[source]",
		"syntax": [
			"divs <source>,Dn"
		],
		"description": "Divide the destination operand by the source operand and store the result in the destination. The destination is a longword and the source is a 16-bit value. The result (i.e., destination register) is a 32-bit value arranged so that the quotient is the lower-order word and the remainder is the upper-order word. `DIVS` performs division on two's complement values. An attempt to divide by zero causes an exception. The sign of the remainder is always the same as the sign of the dividend (unless the remainder is zero).\n\nAttempting to divide a number by zero results in a divide-by-zero exception. If overflow is detected during division, the operands are unaffected. Overflow is checked for at the start of the operation and occurs if the quotient is larger than a 16-bit signed integer. If the upper word of the dividend is greater than or equal to the divisor, the V-bit is set and the instruction terminated.",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"divu": {
		"title": "DIVU",
		"summary": "Unsigned Divide",
		"operation": "[destination] ← [destination]/[source]",
		"syntax": [
			"divu <source>,Dn"
		],
		"description": "Divide the destination operand by the source operand and store the result in the destination. The destination is a longword and the source is a 16-bit value. The result (i.e., destination register) is a 32-bit value arranged so that the quotient is the lower-order word and the remainder is the upper-order word. `DIVU` performs division on unsigned values. An attempt to divide by zero causes an exception.\n\nAttempting to divide a number by zero results in a divide-by-zero exception. If overflow is detected during division, the operands are unaffected. Overflow is checked for at the start of the operation and occurs if the quotient is larger than a 16-bit signed integer. If the upper word of the dividend is greater than or equal to the divisor, the V-bit is set and the instruction terminated.",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"eor": {
		"title": "EOR",
		"summary": "Logical Exclusive-OR",
		"operation": "[destination] ← [source] ⊕ [destination]",
		"syntax": [
			"eor Dn,<destination>"
		],
		"description": "EOR (exclusive or) the source operand with the destination operand and store the result in the destination location Note that the source operand must be a data register and that the operation `EOR <source>,Dn` is not permitted.",
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "*",
			"c": "0",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"jmp": {
		"title": "JMP",
		"summary": "Jump",
		"operation": "[PC] ← destination",
		"syntax": [
			"jmp <destination>"
		],
		"description": "Program execution continues at the effective address specified by the instruction.",
		"src": {
			"dn": false,
			"an": false,
			"anIndirect": true,
			"anPostInc": false,
			"anPreDec": false,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": false
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"jsr": {
		"title": "JSR",
		"summary": "Jump to Subroutine",
		"operation": "[SP] ← [SP] - 4; [M([SP])] ← [PC]<br/>\n[PC] ← destination",
		"syntax": [
			"jsr <destination>"
		],
		"description": "`JSR` pushes the longword address of the instruction immediately following the `JSR` onto the system stack. Program execution then continues at the address specified in the instruction.",
		"src": {
			"dn": false,
			"an": false,
			"anIndirect": true,
			"anPostInc": false,
			"anPreDec": false,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": false
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"ldi": {
		"title": "ldi",
		"summary": "8-bit Load Immediate",
		"operation": "[destination] ← [source]\n[CCR] ← [source]\n[destination] ← [SR]\nIF [S] = 1<br/>&nbsp;&nbsp;THEN [SR] ← [source]<br/>ELSE TRAP\nIF [S] = 1&nbsp;&nbsp;&nbsp;&nbsp;{MOVE USP,An form}<br/> &nbsp;&nbsp;THEN [USP] ← [An]<br/> ELSE TRAP\nIF [S] = 1&nbsp;&nbsp;&nbsp;&nbsp;{MOVE An,USP form}<br/> &nbsp;&nbsp;THEN [An] ← [USP]<br/> ELSE TRAP",
		"syntax": [
			"ldi <source>,<destination>",
			"ldi <source>,CCR",
			"ldi SR,<destination>",
			"ldi <source>,SR",
			"ldi USP,An",
			"ldi An,USP"
		],
		"description": "Move the contents of the source to the destination location. The data is examined as it is moved and the condition codes set accordingly. Note that this is actually a *copy* command because the source is not affected by the move. The move instruction has the widest range of addressing modes of all the 68000's instructions.\n\n**Copy data to CCR from source**\n\nMove the contents of the source operand to the condition code register. The source operand is a *word*, but only the low-order *byte* contains the condition codes. The upper byte is neglected. Note that `MOVE <source>,CCR` is a word operation, but `ANDI`, `ORI`, and `EORI` to `CCR` are all byte operations.\n\n**Copy data from SR to destination**\n\nMove the contents of the status register to the destination location. The source operand, the status register, is a word. This instruction is not privileged in the 68000, but is privileged in the 68010, 68020, and 68030. Executing a `MOVE SR,<destination>` while in the user mode on these processors results in a privilege violation trap.\n\n**Copy data to SR from source**\n\nMove the contents of the source operand to the status register. The source operand is a word and all bits of the status register are affected.\n\n**Copy data to or from USP**\n\nMove the contents of the user stack pointer to an address register or vice versa. This is a privileged instruction and allows the operating system running in the supervisor state either to read the contents of the user stack pointer or to set up the user stack pointer.",
		"src": {
			"dn": true,
			"an": true,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"move": {
		"title": "MOVE",
		"summary": "Move",
		"operation": "[destination] ← [source]\n[CCR] ← [source]\n[destination] ← [SR]\nIF [S] = 1<br/>&nbsp;&nbsp;THEN [SR] ← [source]<br/>ELSE TRAP\nIF [S] = 1&nbsp;&nbsp;&nbsp;&nbsp;{MOVE USP,An form}<br/> &nbsp;&nbsp;THEN [USP] ← [An]<br/> ELSE TRAP\nIF [S] = 1&nbsp;&nbsp;&nbsp;&nbsp;{MOVE An,USP form}<br/> &nbsp;&nbsp;THEN [An] ← [USP]<br/> ELSE TRAP",
		"syntax": [
			"move <source>,<destination>",
			"move <source>,CCR",
			"move SR,<destination>",
			"move <source>,SR",
			"move USP,An",
			"move An,USP"
		],
		"description": "Move the contents of the source to the destination location. The data is examined as it is moved and the condition codes set accordingly. Note that this is actually a *copy* command because the source is not affected by the move. The move instruction has the widest range of addressing modes of all the 68000's instructions.\n\n**Copy data to CCR from source**\n\nMove the contents of the source operand to the condition code register. The source operand is a *word*, but only the low-order *byte* contains the condition codes. The upper byte is neglected. Note that `MOVE <source>,CCR` is a word operation, but `ANDI`, `ORI`, and `EORI` to `CCR` are all byte operations.\n\n**Copy data from SR to destination**\n\nMove the contents of the status register to the destination location. The source operand, the status register, is a word. This instruction is not privileged in the 68000, but is privileged in the 68010, 68020, and 68030. Executing a `MOVE SR,<destination>` while in the user mode on these processors results in a privilege violation trap.\n\n**Copy data to SR from source**\n\nMove the contents of the source operand to the status register. The source operand is a word and all bits of the status register are affected.\n\n**Copy data to or from USP**\n\nMove the contents of the user stack pointer to an address register or vice versa. This is a privileged instruction and allows the operating system running in the supervisor state either to read the contents of the user stack pointer or to set up the user stack pointer.",
		"src": {
			"dn": true,
			"an": true,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"move16": {
		"title": "MOVE16",
		"summary": "16-Byte Block Move",
		"syntax": [],
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"nop": {
		"title": "NOP",
		"summary": "No Operation",
		"operation": "None",
		"syntax": [
			"nop"
		],
		"description": "The no operation instruction, `NOP` performs no *computation*. Execution continues with the instruction following the `NOP` instruction. The processor's state is not modified by a `NOP`.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"not": {
		"title": "NOT",
		"summary": "Logical Complement",
		"operation": "[destination] ← [destination]",
		"syntax": [
			"not <destination>"
		],
		"description": "Calculate the logical complement of the destination and store the result in the destination. The difference between `NOT` and `NEG` is that `NOT` performs a bit-by-bit logical complementation, while a `NEG` performs a two's complement arithmetic subtraction. Moreover, `NEG` updates all bits of the CCR, while `NOT` clears the V- and C-bits, updates the N- and Z-bits, and doesn't affect the X-bit.",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "*",
			"c": "0",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"or": {
		"title": "OR",
		"summary": "Logical Inclusive-OR",
		"operation": "[destination] ← [source] + [destination]",
		"syntax": [
			"or <source>,Dn",
			"or Dn,<destination>"
		],
		"description": "OR the source operand to the destination operand, and store the result in the destination location.",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": true,
			"pcIdx": true,
			"imm": true
		},
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "*",
			"c": "0",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"rol": {
		"title": "ROL",
		"summary": "Rotate Left",
		"operation": "[destination] ← [destination] rotated by \\<count\\>",
		"syntax": [
			"rol [<count>,]<destination>"
		],
		"description": "Rotate the bits of the operand left. The extend bit, X, is not included in the operation. A rotate operation is circular in the sense that the bit shifted out at one end is shifted into the other end. That is, no bit is lost or destroyed by a rotate operation. The bit shifted out is also copied into the C-bit of the CCR, but not into the X-bit. The shift count may be specified in one of three ways: the count may be a literal, the contents of a data register, or the value 1. An immediate count permits a shift of 1 to 8 places. If the count is in a register, the value is modulo 64, allowing a range of 0 to 63. If no count is specified, the *word* at the effective address is rotated by one place (e.g., `ROL <destination>`).\n\n```ascii\n        ┌─────────────────────┐\n┌───┐   │  ┌──────────────┐   │\n│ C │◄──┴──┤ Operand ◄─── │◄──┘\n└───┘      └──────────────┘\n```",
		"src": {
			"dn": true,
			"an": false,
			"anIndirect": false,
			"anPostInc": false,
			"anPreDec": false,
			"anOffset": false,
			"anIdx": false,
			"absW": false,
			"absL": false,
			"pcOffset": false,
			"pcIdx": false,
			"imm": true
		},
		"dest": {
			"dn": true,
			"an": false,
			"anIndirect": true,
			"anPostInc": true,
			"anPreDec": true,
			"anOffset": true,
			"anIdx": true,
			"absW": true,
			"absL": true,
			"pcOffset": false,
			"pcIdx": false,
			"imm": false
		},
		"flags": {
			"z": "*",
			"c": "0",
			"s": "*"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"rts": {
		"title": "RTS",
		"summary": "Return from Subroutine",
		"operation": "[PC] ← [M([SP])]; [SP] ← [SP] + 4",
		"syntax": [
			"rts"
		],
		"description": "The program counter is pulled from the stack and the previous value of the PC is lost. `RTS` is used to terminate a subroutine.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	},
	"stop": {
		"title": "STOP",
		"summary": "Stop",
		"operation": "IF [S] = 1 THEN<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;[SR] ← \\<data\\><br/>\n&nbsp;&nbsp;&nbsp;&nbsp;STOP<br/>\n&nbsp;&nbsp;ELSE TRAP",
		"syntax": [
			"stop #<data>"
		],
		"description": "The immediate operand is copied into the entire status register (i.e., both status byte and *CCR* are modified), and the program counter advanced to point to the next instruction to be executed. The processor then suspends all further processing and halts. That is, the privileged `STOP` instruction stops the 68000.\n\nThe execution of instructions resumes when a trace, an interrupt, or a reset exception occurs. A trace exception will occur if the trace bit is set when the `STOP` instruction is encountered. If an interrupt request arrives whose priority is higher than the current processor priority, an interrupt exception occurs, otherwise the interrupt request has no effect. If the bit of the immediate data corresponding to the S-bit is clear (i.e., user mode selected), execution of the `STOP` instruction will cause a privilege violation. An external reset will always initiate reset exception processing.",
		"flags": {
			"z": "-",
			"c": "-",
			"s": "-"
		},
		"procs": {
			"rcasm": true,
			"rcasm+div": true
		}
	}
}